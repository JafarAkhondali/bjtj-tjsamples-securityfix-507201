/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import kotlinx.coroutines.*
import kotlinx.coroutines.flow.*
import kotlin.system.measureTimeMillis


// Asynchronous Flow
// -----------------
// https://kotlinlang.org/docs/flow.html

class App {

    open class Base {
        open fun run() {
            println("...${this.javaClass.simpleName} is running...")
        }
    }

    class RepresentingMultipleValues : Base() {

        fun simple(): List<Int> = listOf(1, 2, 3)

        override fun run() {
            super.run()
            simple().forEach { value -> println(value) }
        }

        class Sequences : Base() {
            fun simple(): Sequence<Int> = sequence { // sequence builder
                for (i in 1..3) {
                    Thread.sleep(100) // pretend we are computing it
                    yield(i) // yield next value
                }
            }

            override fun run() {
                super.run()
                simple().forEach { value -> println(value) }
            }
        }

        class SuspendingFunctions : Base() {
            suspend fun simple(): List<Int> {
                delay(1000) // pretend we are doing something asynchronous here
                return listOf(1, 2, 3)
            }

            override fun run() = runBlocking<Unit> {
                super.run()
                simple().forEach { value -> println(value) }
            }
        }

        class Flows : Base() {
            fun simple(): Flow<Int> = flow { // flow builder
                for (i in 1..3) {
                    delay(100) // pretend we are doing something useful here
                    emit(i) // emit next value
                }
            }

            override fun run() = runBlocking<Unit> {
                super.run()
                // Launch a concurrent coroutine to check if the main thread is blocked
                launch {
                    for (k in 1..3) {
                        println("I'm not blocked $k")
                        delay(100)
                    }
                }
                // Collect the flow
                simple().collect { value -> println(value) }
            }
        }
    }


    class FlowsAreCold : Base() {
        fun simple(): Flow<Int> = flow {
            println("Flow started")
            for (i in 1..3) {
                delay(100)
                emit(i)
            }
        }

        override fun run() = runBlocking<Unit> {
            super.run()
            println("Calling simple function...")
            val flow = simple()
            println("Calling collect...")
            flow.collect { value -> println(value) }
            println("Calling collect again...")
            flow.collect { value -> println(value) }
        }
    }


    class FlowCancellationBasics : Base() {
        fun simple(): Flow<Int> = flow {
            for (i in 1..3) {
                delay(100)
                println("Emitting $i")
                emit(i)
            }
        }

        override fun run() = runBlocking<Unit> {
            super.run()
            withTimeoutOrNull(250) { // Timeout after 250ms
                simple().collect { value -> println(value) }
            }
            println("Done")
        }
    }


    class FlowBuilders : Base() {
        override fun run() = runBlocking {
            super.run()
            (1..3).asFlow().collect { value -> println(value) }
        }
    }


    class IntermediateFlowOperators : Base() {
        suspend fun performRequest(request: Int): String {
            delay(1000) // imitate long-running asynchronous work
            return "response $request"
        }

        override fun run() = runBlocking {
            super.run()
            (1..3).asFlow() // a flow of requests
                .map { request -> performRequest(request) }
                .collect { response -> println(response) }
        }

        inner class TransformOperator : Base() {
            override fun run() = runBlocking {
                super.run()
                (1..3).asFlow()
                    .transform { request ->
                        emit("Making request $request")
                        emit(performRequest(request))
                    }
                    .collect { response -> println(response) }
            }
        }

        class SizeLimitingOperators : Base() {
            fun numbers(): Flow<Int> = flow {
                try {
                    emit(1)
                    emit(2)
                    println("This line will not execute")
                    emit(3)
                } finally {
                    println("Finally in numbers")
                }
            }

            override fun run() = runBlocking {
                super.run()
                numbers()
                    .take(2) // take only the first two
                    .collect { value -> println(value) }
            }
        }
    }


    class TerminalFlowOperators : Base() {
        override fun run() = runBlocking {
            super.run()
            val sum = (1..5).asFlow()
                .map { it * it } // squares of numbers from 1 to 5
                .reduce { a, b -> a + b } // sum them (terminal operator)
            println(sum)
        }
    }


    class FlowsAreSequential : Base() {
        override fun run() = runBlocking {
            super.run()
            (1..5).asFlow()
                .filter {
                    println("Filter $it")
                    it % 2 == 0
                }
                .map {
                    println("Map $it")
                    "string $it"
                }
                .collect {
                    println("Collect $it")
                }
        }
    }


    class FlowContext : Base() {

        companion object {
            fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")
        }

        fun simple(): Flow<Int> = flow {
            log("Started simple flow")
            for (i in 1..3) {
                emit(i)
            }
        }


        override fun run() = runBlocking {
            super.run()
            simple().collect { value -> log("Collected $value") }
        }

        class ACommonPitfallWhenUsingWithContext : Base() {
            fun simple(): Flow<Int> = flow {
//                The WRONG way to change context for CPU-consuming code in flow builder
                kotlinx.coroutines.withContext(Dispatchers.Default) {
                    for (i in 1..3) {
                        Thread.sleep(100) // pretend we are computing it in CPU-consuming way
                        emit(i) // emit next value
                    }
                }
            }

            override fun run() = runBlocking {
                super.run()
                try {
                    simple().collect { value -> println(value) }
                } catch (e: Exception) {
                    e.printStackTrace()
//                    Output(example):
//
//                    java.lang.IllegalStateException: Flow invariant is violated:
//                            Flow was collected in [BlockingCoroutine{Active}@2eff649b, BlockingEventLoop@6bfdef20],
//                            but emission happened in [DispatchedCoroutine{Active}@7719cde3, Dispatchers.Default].
//                            Please refer to 'flow' documentation or use 'flowOn' instead
//                        at kotlinx.coroutines.flow.internal.SafeCollector_commonKt.checkContext(SafeCollector.common.kt:84)
//                        at kotlinx.coroutines.flow.internal.SafeCollector.checkContext(SafeCollector.kt:132)
//                        at kotlinx.coroutines.flow.internal.SafeCollector.emit(SafeCollector.kt:109)
//                        at kotlinx.coroutines.flow.internal.SafeCollector.emit(SafeCollector.kt:82)
//                        at org.example.App$FlowContext$ACommonPitfallWhenUsingWithContext$simple$1$1.invokeSuspend(App.kt:227)
//                        at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
//                        at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:102)
//                        at kotlinx.coroutines.scheduling.CoroutineScheduler.runSafely(CoroutineScheduler.kt:589)
//                        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.executeTask(CoroutineScheduler.kt:816)
//                        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.runWorker(CoroutineScheduler.kt:720)
//                        at kotlinx.coroutines.scheduling.CoroutineScheduler$Worker.run(CoroutineScheduler.kt:707)
                }
            }

            class FlowOnOperator : Base() {
                fun simple(): Flow<Int> = flow {
                    for (i in 1..3) {
                        Thread.sleep(100) // pretend we are computing it in CPU-consuming way
                        emit(i) // emit next value
                    }
                }.flowOn(Dispatchers.Default) // RIGHT way to change context for CPU-consuming code in flow builder

                override fun run() = runBlocking {
                    super.run()
                    simple().collect { value -> log("Collected $value") }
                }

            }
        }
    }


    class Buffering : Base() {

        companion object {
            fun simple(): Flow<Int> = flow {
                for (i in 1..3) {
                    delay(100) // pretend we are asynchronously waiting 100 ms
                    emit(i) // emit next value
                }
            }
        }

        override fun run() = runBlocking {
            super.run()
            val time = measureTimeMillis {
                simple().collect { value ->
                    delay(300) // pretend we are processing it for 300 ms
                    println(value)
                }
            }
            println("Collected in $time ms")
        }

        class Conflation : Base() {
            override fun run() = runBlocking {
                super.run()
                val time = measureTimeMillis {
                    simple()
                        .conflate() // conflate emissions, don't process each one
                        .collect { value ->
                            delay(300) // pretend we are processing it for 300 ms
                            println(value)
                        }
                }
                println("Collected in $time ms")
            }
        }

        class ProcessingTheLatestValue : Base() {
            override fun run() = runBlocking {
                super.run()
                val time = measureTimeMillis {
                    simple()
                        .collectLatest { value -> // cancel & restart on the latest value
                            println("Collecting $value")
                            delay(300) // pretend we are processing it for 300 ms
                            println("Done $value")
                        }
                }
                println("Collected in $time ms")
            }
        }
    }


    class ComposingMultipleFlows {

        class Zip : Base() {
            override fun run() = runBlocking {
                super.run()
                val nums = (1..3).asFlow() // numbers 1..3
                val strs = flowOf("one", "two", "three") // compose a single string
                nums.zip(strs) { a, b -> "$a -> $b" } // compose a single string
                    .collect { println(it) } // collect and print
            }
        }

        class Combine : Base() {
            override fun run() = runBlocking {
                super.run()
                println(" -- zip way -- ")
                zipWay()
                println(" -- combine way -- ")
                combineWay()
            }

            fun zipWay() = runBlocking {
                val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
                val strs =
                    flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms
                val startTime = System.currentTimeMillis() // remember the start time
                nums.zip(strs) { a, b -> "$a -> $b" } // compose a single string with "zip"
                    .collect { value -> // collect and print
                        println("$value at ${System.currentTimeMillis() - startTime} ms from start")
                    }
            }

            fun combineWay() = runBlocking {
                val nums = (1..3).asFlow().onEach { delay(300) } // numbers 1..3 every 300 ms
                val strs =
                    flowOf("one", "two", "three").onEach { delay(400) } // strings every 400 ms
                val startTime = System.currentTimeMillis() // remember the start time
                nums.combine(strs) { a, b -> "$a -> $b" } // compose a single string with "combine"
                    .collect { value -> // collect and print
                        println("$value at ${System.currentTimeMillis() - startTime} ms from start")
                    }
            }
        }
    }

    class FlatteningFlows : Base() {

        companion object {
            fun requestFlow(i: Int): Flow<String> = flow {
                emit("$i: First")
                delay(500) // wait 500 ms
                emit("$i: Second")
            }
        }

        class FlatMapConcat : Base() {
            @OptIn(ExperimentalCoroutinesApi::class)
            override fun run() = runBlocking {// remember the start time
                super.run()
                var startTime = System.currentTimeMillis()
                (1..3).asFlow().onEach { delay(100) } // emit a number every 100 ms
                    .flatMapConcat { requestFlow(it) }
                    .collect { value -> // collect and print
                        println("$value at ${System.currentTimeMillis() - startTime} ms from start")
                    }
            }
        }

        class FlatMapMerge : Base() {
            @OptIn(ExperimentalCoroutinesApi::class)
            override fun run() = runBlocking {
                super.run()
                val startTime = System.currentTimeMillis()
                (1..3).asFlow().onEach { delay(100) } // emit a number every 100 ms
                    .flatMapMerge { requestFlow(it) }
                    .collect { value -> // collect and print
                        println("$value at ${System.currentTimeMillis() - startTime} ms from start")
                    }
            }
        }

        class FlatMapLatest : Base() {
            @OptIn(ExperimentalCoroutinesApi::class)
            override fun run() = runBlocking {
                super.run()
                val startTime = System.currentTimeMillis()
                (1..3).asFlow().onEach { delay(100) } // emit a number every 100 ms
                    .flatMapLatest { requestFlow(it) }
                    .collect { value -> // collect and print
                        println("$value at ${System.currentTimeMillis() - startTime} ms from start")
                    }
            }
        }
    }


    class FlowExceptions {

        class CollectorTryAndCatch : Base() {
            fun simple(): Flow<Int> = flow {
                for (i in 1..3) {
                    println("Emitting $i")
                    emit(i) // emit next value
                }
            }

            override fun run() = runBlocking {
                super.run()
                try {
                    simple().collect { value ->
                        println(value)
                        check(value <= 1) { "Collected $value" }
                    }
                } catch (e: Throwable) {
                    println("Caught $e")
                }
            }
        }

        class EverythingIsCaught : Base() {
            fun simple(): Flow<String> = flow {
                for (i in 1..3) {
                    println("Emitting $i")
                    emit(i) // emit next value
                }
            }.map { value ->
                check(value <= 1) { "Crashed on $value" }
                "string $value"
            }

            override fun run() = runBlocking {
                super.run()
                try {
                    simple().collect { value -> println(value) }
                } catch (e: Throwable) {
                    println("Caught $e")
                }
            }
        }
    }


    class ExceptionTransparency : Base() {

        fun simple(): Flow<String> = flow {
            for (i in 1..3) {
                println("Emitting $i")
                emit(i) // emit next value
            }
        }.map { value ->
            check(value <= 1) { "Crashed on $value" }
            "string $value"
        }

        override fun run() = runBlocking {
            super.run()
            simple()
                .catch { e -> emit("Caught $e") } // emit on exception
                .collect { value -> println(value) }
        }

        class TransparentCatch : Base() {
            fun simple(): Flow<Int> = flow {
                for (i in 1..3) {
                    println("Emitting $i")
                    emit(i)
                }
            }

            override fun run() = runBlocking {
                super.run()

                try {
                    simple()
                        .catch { e -> println("Caught $e") }
                        .collect { value ->
                            check(value <= 1) { "Collected $value" }
                            println(value)
                        }
                } catch (e: Throwable) {
                    e.printStackTrace()
//                    Output(example):
//
//                    java.lang.IllegalStateException: Collected 2
//                        at org.example.App$ExceptionTransparency$TransparentCatch$run$1$2.emit(App.kt:511)
//                        at org.example.App$ExceptionTransparency$TransparentCatch$run$1$2.emit(App.kt:510)
//                        at kotlinx.coroutines.flow.FlowKt__ErrorsKt$catchImpl$2.emit(Errors.kt:154)
//                        at kotlinx.coroutines.flow.internal.SafeCollectorKt$emitFun$1.invoke(SafeCollector.kt:11)
//                        at kotlinx.coroutines.flow.internal.SafeCollectorKt$emitFun$1.invoke(SafeCollector.kt:11)
//                        at kotlinx.coroutines.flow.internal.SafeCollector.emit(SafeCollector.kt:113)
//                        at kotlinx.coroutines.flow.internal.SafeCollector.emit(SafeCollector.kt:82)
//                        at org.example.App$ExceptionTransparency$TransparentCatch$simple$1.invokeSuspend(App.kt:500)
//                        at org.example.App$ExceptionTransparency$TransparentCatch$simple$1.invoke(App.kt)
//                        at org.example.App$ExceptionTransparency$TransparentCatch$simple$1.invoke(App.kt)
//                        at kotlinx.coroutines.flow.SafeFlow.collectSafely(Builders.kt:57)
//                        at kotlinx.coroutines.flow.AbstractFlow.collect(Flow.kt:226)
//                        at kotlinx.coroutines.flow.FlowKt__ErrorsKt.catchImpl(Errors.kt:152)
//                        at kotlinx.coroutines.flow.FlowKt.catchImpl(Unknown Source)
//                        at kotlinx.coroutines.flow.FlowKt__ErrorsKt$catch$$inlined$unsafeFlow$1.collect(SafeCollector.common.kt:109)
//                        at org.example.App$ExceptionTransparency$TransparentCatch$run$1.invokeSuspend(App.kt:510)
//                        at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
//                        at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:102)
//                        at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:263)
//                        at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:95)
//                        at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:69)
//                        at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)
//                        at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:47)
//                        at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)
//                        at org.example.App$ExceptionTransparency$TransparentCatch.run(App.kt:504)
//                        at org.example.AppKt.main(App.kt:581)
//                        at org.example.AppKt.main(App.kt)
                }
            }
        }

        class CatchingDeclaratively : Base() {

            fun simple(): Flow<Int> = flow {
                for (i in 1..3) {
                    println("Emitting $i")
                    emit(i)
                }
            }

            override fun run() = runBlocking {
                super.run()
                simple()
                    .onEach { value ->
                        check(value <= 1) { "Collected $value" }
                        println(value)
                    }
                    .catch { e -> println("Caught $e") }
                    .collect()
            }
        }
    }


    class FlowCompletion {

        class ImperativeFinallyBlock : Base() {
            companion object {
                fun simple(): Flow<Int> = (1..3).asFlow()
            }

            override fun run() = runBlocking {
                super.run()
                try {
                    simple().collect { value ->
                        println(value)
                    }
                } finally {
                    println("Done")
                }
            }
        }

        class DeclarativeHandling : Base() {

            fun simple(): Flow<Int> = flow {
                emit(1)
                throw RuntimeException()
            }

            override fun run() = runBlocking {
                super.run()
                ImperativeFinallyBlock.simple()
                    .onCompletion { println("Done") }
                    .collect { value -> println(value) }

                simple()
                    .onCompletion { cause -> if (cause != null) println("Flow completed exceptionally") }
                    .catch { e -> println("Caught exception") }
                    .collect { value -> println(value) }
            }
        }

        class SuccessfulCompletion : Base() {
            fun simple(): Flow<Int> = (1..3).asFlow()

            override fun run() = runBlocking {
                super.run()

                try {
                    simple()
                        .onCompletion { cause -> println("Flow completed with $cause") }
                        .collect { value ->
                            check(value <= 1) { "Collected $value" }
                            println(value)
                        }
                } catch (e: Throwable) {
                    e.printStackTrace()
//                    Output(example):
//
//                    java.lang.IllegalStateException: Collected 2
//                        at org.example.App$FlowCompletion$SuccessfulCompletion$run$1$2.emit(App.kt:622)
//                        at org.example.App$FlowCompletion$SuccessfulCompletion$run$1$2.emit(App.kt:621)
//                        at kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$9.collect(SafeCollector.common.kt:111)
//                        at kotlinx.coroutines.flow.FlowKt__EmittersKt$onCompletion$$inlined$unsafeFlow$1.collect(SafeCollector.common.kt:110)
//                        at org.example.App$FlowCompletion$SuccessfulCompletion$run$1.invokeSuspend(App.kt:621)
//                        at kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)
//                        at kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:102)
//                        at kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:263)
//                        at kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:95)
//                        at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:69)
//                        at kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)
//                        at kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:47)
//                        at kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)
//                        at org.example.App$FlowCompletion$SuccessfulCompletion.run(App.kt:615)
//                        at org.example.AppKt.main(App.kt:691)
//                        at org.example.AppKt.main(App.kt)
                }
            }
        }
    }

    class LaunchingFlow : Base() {
        fun events(): Flow<Int> = (1..3).asFlow().onEach { delay(100) }

        override fun run() = runBlocking {
            super.run()

            syncWay()
            asyncWay()

        }

        fun syncWay() = runBlocking {
            events()
                .onEach { event -> println("Event: $event") }
                .collect() // <--- Collecting the flow waits
            println("Done")
        }

        fun asyncWay() = runBlocking {
            events()
                .onEach { event -> println("Event: $event") }
                .launchIn(this) // <--- Launching the flow in a separate coroutine
            println("Done")
        }


        class FlowCancellationChecks : Base() {
            fun foo(): Flow<Int> = flow {
                for (i in 1..5) {
                    println("Emitting $i")
                    emit(i)
                }
            }

            override fun run() {
                super.run()
                try {
                    runBlocking {
                        foo()
                            .collect { value ->
                                if (value == 3) cancel()
                                println(value)
                            }
                    }
                } catch (e: Throwable) {
                    e.printStackTrace()
//                    kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine{Cancelled}@68be2bc2
                }

                try {
                    runBlocking {
                        (1..5).asFlow().collect { value ->
                            if (value == 3) cancel()
                            println(value)
                        }
                    }
                } catch (e: Throwable) {
                    e.printStackTrace()
//                    kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine{Cancelled}@675d3402
                }
            }
        }

        class MakingBusyFlowCancellable : Base() {
            override fun run() {
                super.run()

                try {
                    runBlocking {
                        (1..5).asFlow().cancellable().collect { value ->
                            if (value == 3) cancel()
                            println(value)
                        }
                    }
                } catch (e: Throwable) {
                    e.printStackTrace()
//                    kotlinx.coroutines.JobCancellationException: BlockingCoroutine was cancelled; job=BlockingCoroutine{Cancelled}@5c7fa833
                }
            }
        }
    }
}

fun main() {
// Representing multiple values﻿
    App.RepresentingMultipleValues().run()
    App.RepresentingMultipleValues.Sequences().run()
    App.RepresentingMultipleValues.SuspendingFunctions().run()
    App.RepresentingMultipleValues.Flows().run()

// Flows are cold﻿
    App.FlowsAreCold().run()

// Flow cancellation basics﻿
    App.FlowCancellationBasics().run()

// Flow builders
    App.FlowBuilders().run()

// Intermediate flow operators
    App.IntermediateFlowOperators().run()
    App.IntermediateFlowOperators().TransformOperator().run()
    App.IntermediateFlowOperators.SizeLimitingOperators().run()

// Terminal flow operators
    App.TerminalFlowOperators().run()

// Flows are sequential
    App.FlowsAreSequential().run()

// Flow context
    App.FlowContext().run()
    App.FlowContext.ACommonPitfallWhenUsingWithContext().run()
    App.FlowContext.ACommonPitfallWhenUsingWithContext.FlowOnOperator().run()

// Buffering
    App.Buffering().run()
    App.Buffering.Conflation().run()
    App.Buffering.ProcessingTheLatestValue().run()

// Composing multiple flows
    App.ComposingMultipleFlows.Zip().run()
    App.ComposingMultipleFlows.Combine().run()

// Flattening flows
    App.FlatteningFlows.FlatMapConcat().run()
    App.FlatteningFlows.FlatMapMerge().run()
    App.FlatteningFlows.FlatMapLatest().run()

// Flow exceptions
    App.FlowExceptions.CollectorTryAndCatch().run()
    App.FlowExceptions.EverythingIsCaught().run()

// Exception transparency
    App.ExceptionTransparency().run()
    App.ExceptionTransparency.TransparentCatch().run()
    App.ExceptionTransparency.CatchingDeclaratively().run()

// Flow completion
    App.FlowCompletion.ImperativeFinallyBlock().run()
    App.FlowCompletion.DeclarativeHandling().run()
    App.FlowCompletion.SuccessfulCompletion().run()

// Launching flow
    App.LaunchingFlow().run()
    App.LaunchingFlow.FlowCancellationChecks().run()
    App.LaunchingFlow.MakingBusyFlowCancellable().run()
}
