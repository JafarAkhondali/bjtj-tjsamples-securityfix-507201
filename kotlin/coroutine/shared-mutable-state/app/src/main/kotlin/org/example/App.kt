/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import kotlin.system.measureTimeMillis
import kotlinx.coroutines.*
import kotlinx.coroutines.sync.*
import java.util.concurrent.atomic.AtomicInteger

// https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#volatiles-are-of-no-help

class App {

    companion object {
        suspend fun massiveRun(action: suspend () -> Unit) {
            val n = 1000 // number of coroutines to launch
            val k = 1000 // number of coroutines to launch
            val time = measureTimeMillis {
                coroutineScope {
                    repeat(n) {
                        launch {
                            repeat(k) { action() }
                        }
                    }
                }
            }
            println("Completed ${n * k} actions in $time ms")
        }
    }


    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#the-problem
    class Problem {

        // What does it print at the end? It is highly unlikely to ever print "Counter = 100000", because a hundred coroutines increment the counter concurrently from multiple threads without any synchronization.

        var counter = 0

        fun main() = runBlocking {
            withContext(Dispatchers.Default) {
                massiveRun {
                    counter++
                }
            }
            println("Counter = $counter")
        }
    }

    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#volatiles-are-of-no-help
    class VolatilesAreOfNoHelp {

        // his code works slower, but we still don't always get "Counter = 100000" at the end, because volatile variables guarantee linearizable (this is a technical term for "atomic") reads and writes to the corresponding variable, but do not provide atomicity of larger actions (increment in our case).

        @Volatile // in Kotlin, `volatile` is an annotation
        var counter = 0

        fun main() = runBlocking {
            withContext(Dispatchers.Default) {
                massiveRun {
                    counter++
                }
            }
            println("Counter = $counter")
        }
    }

    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#thread-safe-data-structures
    class ThreadSafeDataStructures {

        var counter = AtomicInteger()

        fun main() = runBlocking {
            withContext(Dispatchers.Default) {
                massiveRun {
                    counter.incrementAndGet()
                }
            }
            println("Counter = $counter")
        }
    }

    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#thread-confinement-fine-grained
    class ThreadConfinementFineGrained {
        @OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
        val counterContext = newSingleThreadContext("CounterContext")
        var counter = 0

        fun main() = runBlocking {
            withContext(Dispatchers.Default) {
                massiveRun {
                    // confine each increment to a single-threaded context
                    withContext(counterContext) {
                        counter++
                    }
                }
            }
            println("Counter = $counter")
        }
    }

    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#thread-confinement-coarse-grained
    class ThreadConfinementCoarseGrained {
        @OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
        val counterContext = newSingleThreadContext("CounterContext")
        var counter = 0

        fun main() = runBlocking {
            // confine everything to a single-threaded context
            withContext(counterContext) {
                massiveRun {
                    counter++
                }
            }
            println("Counter = $counter")
        }
    }

    // https://kotlinlang.org/docs/shared-mutable-state-and-concurrency.html#mutual-exclusion
    class MutualExclusion {
        val mutex = Mutex()
        var counter = 0

        fun main() = runBlocking {
            withContext(Dispatchers.Default) {
                massiveRun {
                    // protect each increment with lock
                    mutex.withLock {
                        counter++
                    }
                }
            }
            println("Counter = $counter")
        }
    }
}

fun main() {
    App.Problem().main()
    App.VolatilesAreOfNoHelp().main()
    App.ThreadSafeDataStructures().main()
    App.ThreadConfinementFineGrained().main()
    App.ThreadConfinementCoarseGrained().main()
    App.MutualExclusion().main()
}
